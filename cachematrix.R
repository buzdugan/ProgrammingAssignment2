## These 2 functions generate and cache the inverse of a square matrix.


#This function generates a list of 4 functions:
#1.set the matrix (overwrites the initial square matrix x)
#2.get the matrix(returns the square matrix)
#3.setinv of the matrix (calculates the invert of the square matrix)
#4.getinv of the matrix (return the invert of the square matrix)

makeCacheMatrix <- function(x = matrix()) {
  
  #set the inverse matrix to NULL
  #which means that it doesn't exist
  inv <- NULL
  
  #create a function that overwrites the initial matrix x
  set <- function(y) {
    x <<- y
    inv <<- NULL
  }
  
  #create a function that returns a matrix 
  get <- function() x
  
  #create a function that sets the inverse of a matrix (calculated somewhere else)
  #invmat is a parametre
  setinv <- function(invmat) inv <<- invmat
  
  #create a function that returns the inverse of the matrix
  #returns a matrix
  getinv <- function() inv
  
  #makeCacheMatrix returns a list of functions, which have been assigned names 
  #(name of element in list = function name)
  list(set = set, get = get,
       setinv = setinv,
       getinv = getinv)
}




#This function calculates the inverse of a matrix called by the makeCacheMatrix function 
#it first checks if the inverse has already been calculated
#if so, it gets the inverse from the cache and skips the computation
#otherwise, it calculates the inverse of the matrix and puts it in the cache via the setinv function.

#x is the list of the 4 functions generated by makeCacheMatrix

cacheSolve <- function(x, ...) {  
  inv <- x$getinv()
  
  #check if the inverse matrix (inv) exists
  if(!is.null(inv)) {
    message("getting cached data")
    return(inv)
  }
  
  #if the inverse matrix doesn't exist already then
  #generate the matrix
  data <- x$get()
  #calculate the inverse
  inv <- solve(data, ...)
  #call the setinv function which stores the value of the inverse matrix 
  x$setinv(inv)  
  #return inverse
  inv
}